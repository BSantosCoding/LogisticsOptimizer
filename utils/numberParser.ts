/**
 * Parses a string number that may be in various locale formats.
 * Handles:
 * - US/Standard: 1,234.56
 * - EU: 1.234,56 or 100.100,20
 * - Plain: 1234.56 or 1234
 * 
 * Heuristics:
 * - If only one type of separator is present:
 *   - If it appears multiple times (e.g. 1.000.000), it's a thousands separator.
 *   - If it appears once:
 *     - If it's a dot, assume decimal (unambiguous for programming, ambiguous for locales but standardizing on dot usually safer unless instructed otherwise. HOWEVER, given the user issue `100.100,20`, we assume `.` can be thousands).
 *     - CAREFUL: "1,234" (US 1234) vs "1,234" (EU 1.234). 
 *     - We will prioritize standard US float parsing if it looks like a valid float and there aren't conflicting signals, BUT 
 *     - The user specifically mentioned `100.100,20` (dot thousands, comma decimal).
 * 
 * Refined Logic:
 * 1. Remove all whitespace.
 * 2. Check for presence of '.' and ','.
 * 3. If BOTH are present:
 *    - The LAST occurrence dictates the decimal separator.
 *    - If '.' is last (1,234.56), assume US format -> remove ',', keep '.'.
 *    - If ',' is last (1.234,56), assume EU format -> remove '.', replace ',' with '.'.
 * 4. If ONLY '.' is present:
 *    - "1.234" -> Could be 1234 (EU) or 1.234 (US).
 *    - "1.234.567" -> Definitely EU thousands.
 *    - Heuristic: If multiple dots, they are thousands -> remove them.
 *    - If single dot: Assume standard decimal float (safe default for 1.5 etc, unless context implies otherwise).
 * 5. If ONLY ',' is present:
 *    - "1,234" -> Could be 1234 (US) or 1.234 (EU).
 *    - "1,234,567" -> Definitely US thousands.
 *    - Heuristic: If multiple commas, they are thousands -> remove them.
 *    - If single comma: Treat as decimal if it makes sense? or Thousands?
 *    - Standard JS `parseFloat` handles `.` but stops at `,`. 
 *    - We will assume single comma is DECIMAL if we are in a mixed environment, OR thousands if US. This is consistently ambiguous. 
 *    - SAFEST bet for CSVs often generated by Excel in EU: Comma is decimal. 
 *    - BUT `1,000` is often thousands.
 *    - Let's look at the specific problematic format: `100.100,20` -> This is clearly EU.
 *    - If we see `100,100.20` -> This is US.
 *    - If we see `100100,20` -> EU Decimal.
 *    
 *    Let's stick to the "Last Separator" rule for mixed, and "Standard Float" for single dot.
 *    For single comma: `123,45` -> 123.45. `1,234` -> 1234? Or 1.234?
 *    Context suggests the user deals with weights/quantities. `1,234` quantity usually means 1234. `1,234` weight might be 1.234.
 *    However, standard "US" CSVs usually quote things: "1,234" -> 1234.
 *    
 *    Let's try to detect if it's a valid float first.
 */
export function parseLocaleNumber(value: string | undefined | null): number | undefined {
    if (!value) return undefined;
    const cleanVal = value.trim();
    if (cleanVal === '') return undefined;

    // First, simple check: is it already a simple number? (no commas, one dot max)
    // ^-?\d+(\.\d+)?$ 
    if (/^-?\d+(\.\d+)?$/.test(cleanVal)) {
        return parseFloat(cleanVal);
    }

    const dotCount = (cleanVal.match(/\./g) || []).length;
    const commaCount = (cleanVal.match(/,/g) || []).length;
    const lastDotIndex = cleanVal.lastIndexOf('.');
    const lastCommaIndex = cleanVal.lastIndexOf(',');

    // Case 1: Mixed separators (e.g. 1.234,56 or 1,234.56)
    if (dotCount > 0 && commaCount > 0) {
        if (lastDotIndex > lastCommaIndex) {
            // US Format: 1,234,567.89
            // Remove commas, keep dot
            return parseFloat(cleanVal.replace(/,/g, ''));
        } else {
            // EU Format: 1.234.567,89
            // Remove dots, replace comma with dot
            return parseFloat(cleanVal.replace(/\./g, '').replace(',', '.'));
        }
    }

    // Case 2: Only Dots
    if (dotCount > 0) {
        // "1.234.567" -> Thousands (1234567)
        if (dotCount > 1) {
            return parseFloat(cleanVal.replace(/\./g, ''));
        }
        // "1.234" -> Ambiguous. JS standard is decimal. Let's keep it decimal unless we have strong reason not to.
        return parseFloat(cleanVal);
    }

    // Case 3: Only Commas
    if (commaCount > 0) {
        // "1,234,567" -> Thousands (1234567)
        if (commaCount > 1) {
            return parseFloat(cleanVal.replace(/,/g, ''));
        }
        // "1,234" -> Ambiguous.
        // "123,45" -> Decimal (123.45)
        // Heuristic: Check digits after LAST comma. If exactly 3, might be thousands. If 2, definitely decimal.
        // Actually, user example `100.100,20` (EU) implies comma is decimal.
        // If we assumed US default before/elsewhere, "1,234" was probably 1234.

        // Let's look at the structure.
        // If it matches `\d+,\d{2}$` -> highly likely decimal (money/weight).
        // If it matches `\d{1,3},\d{3}$` -> highly likely thousands.

        if (/^\d{1,3}(,\d{3})+$/.test(cleanVal)) {
            // Looks like standard thousands separation (1,000 or 1,000,000)
            return parseFloat(cleanVal.replace(/,/g, ''));
        }

        // Otherwise assume comma is decimal (common in EU/generic data dump)
        // e.g. "100,2" -> 100.2
        return parseFloat(cleanVal.replace(',', '.'));
    }

    // Fallback for simple integers or weird strings
    return parseFloat(cleanVal);
}
